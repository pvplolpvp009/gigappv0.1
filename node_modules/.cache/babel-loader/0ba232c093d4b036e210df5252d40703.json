{"ast":null,"code":"import _objectSpread from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\n\nvar animateMotionValue = function animateMotionValue(name, value, target) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var element = arguments.length > 4 ? arguments[4] : undefined;\n  var isHandoff = arguments.length > 5 ? arguments[5] : undefined;\n  return function (_onComplete) {\n    var valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n\n    var delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n\n    var _transition$elapsed = transition.elapsed,\n        elapsed = _transition$elapsed === void 0 ? 0 : _transition$elapsed;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n\n    var options = _objectSpread(_objectSpread({\n      keyframes: Array.isArray(target) ? target : [null, target],\n      ease: \"easeOut\",\n      velocity: value.getVelocity()\n    }, valueTransition), {}, {\n      delay: -elapsed,\n      onUpdate: function onUpdate(v) {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: function onComplete() {\n        _onComplete();\n\n        valueTransition.onComplete && valueTransition.onComplete();\n      },\n      name: name,\n      motionValue: value,\n      element: isHandoff ? undefined : element\n    });\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n\n\n    if (!isTransitionDefined(valueTransition)) {\n      options = _objectSpread(_objectSpread({}, options), getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n\n\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n\n    if (options.from !== undefined) {\n      options.keyframes[0] = options.from;\n    }\n\n    var shouldSkip = false;\n\n    if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n      options.duration = 0;\n\n      if (options.delay === 0) {\n        shouldSkip = true;\n      }\n    }\n\n    if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n      shouldSkip = true;\n      options.duration = 0;\n      options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n\n\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n      var finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n\n      if (finalKeyframe !== undefined) {\n        frame.update(function () {\n          options.onUpdate(finalKeyframe);\n          options.onComplete();\n        }); // We still want to return some animation controls here rather\n        // than returning undefined\n\n        return new GroupPlaybackControls([]);\n      }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n\n\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n      return new AcceleratedAnimation(options);\n    } else {\n      return new MainThreadAnimation(options);\n    }\n  };\n};\n\nexport { animateMotionValue };","map":{"version":3,"names":["secondsToMilliseconds","getDefaultTransition","getValueTransition","isTransitionDefined","MotionGlobalConfig","instantAnimationState","getFinalKeyframe","frame","AcceleratedAnimation","MainThreadAnimation","GroupPlaybackControls","animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","duration","repeatDelay","from","shouldSkip","type","current","skipAnimations","get","finalKeyframe","update","supports"],"sources":["C:/Users/pvplo/OneDrive/Рабочий стол/editpallav-main/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}