{"ast":null,"code":"import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\nvar handoffFrameTime;\n\nfunction handoffOptimizedAppearAnimation(elementId, valueName,\n/**\n * Legacy arguments. This function is inlined as part of SSG so it can be there's\n * a version mismatch between the main included Motion and the inlined script.\n *\n * Remove in early 2024.\n */\n_value, frame) {\n  var optimisedValueName = transformProps.has(valueName) ? \"transform\" : valueName;\n  var storeId = appearStoreId(elementId, optimisedValueName);\n  var optimisedAnimation = appearAnimationStore.get(storeId);\n\n  if (!optimisedAnimation) {\n    return null;\n  }\n\n  var animation = optimisedAnimation.animation,\n      startTime = optimisedAnimation.startTime;\n\n  var cancelAnimation = function cancelAnimation() {\n    appearAnimationStore.delete(storeId);\n\n    if (frame) {\n      /**\n       * If we've been provided the frameloop as an argument, use it to defer\n       * cancellation until keyframes of the subsequent animation have been resolved.\n       * This \"papers over\" a gap where the JS animations haven't rendered with\n       * the latest time after a potential heavy blocking workload.\n       * Otherwise cancel immediately.\n       *\n       * This is an optional dependency to deal with the fact that this inline\n       * script and the library can be version sharded, and there have been\n       * times when this isn't provided as an argument.\n       */\n      frame.render(function () {\n        return frame.render(function () {\n          try {\n            animation.cancel();\n          } catch (error) {}\n        });\n      });\n    } else {\n      try {\n        animation.cancel();\n      } catch (error) {}\n    }\n  };\n  /**\n   * If the startTime is null, this animation is the Paint Ready detection animation\n   * and we can cancel it immediately without handoff.\n   *\n   * Or if we've already handed off the animation then we're now interrupting it.\n   * In which case we need to cancel it.\n   */\n\n\n  if (startTime === null || window.HandoffComplete) {\n    cancelAnimation();\n    return null;\n  } else {\n    /**\n     * Otherwise we're handing off this animation to the main thread.\n     *\n     * Record the time of the first handoff. We call performance.now() once\n     * here and once in startOptimisedAnimation to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n    if (handoffFrameTime === undefined) {\n      handoffFrameTime = performance.now();\n    }\n    /**\n     * We use main thread timings vs those returned by Animation.currentTime as it\n     * can be the case, particularly in Firefox, that currentTime doesn't return\n     * an updated value for several frames, even as the animation plays smoothly via\n     * the GPU.\n     */\n\n\n    return handoffFrameTime - startTime || 0;\n  }\n}\n\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["transformProps","appearAnimationStore","appearStoreId","handoffFrameTime","handoffOptimizedAppearAnimation","elementId","valueName","_value","frame","optimisedValueName","has","storeId","optimisedAnimation","get","animation","startTime","cancelAnimation","delete","render","cancel","error","window","HandoffComplete","undefined","performance","now"],"sources":["C:/Users/pvplo/OneDrive/Рабочий стол/editpallav-main/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nlet handoffFrameTime;\nfunction handoffOptimizedAppearAnimation(elementId, valueName, \n/**\n * Legacy arguments. This function is inlined as part of SSG so it can be there's\n * a version mismatch between the main included Motion and the inlined script.\n *\n * Remove in early 2024.\n */\n_value, frame) {\n    const optimisedValueName = transformProps.has(valueName)\n        ? \"transform\"\n        : valueName;\n    const storeId = appearStoreId(elementId, optimisedValueName);\n    const optimisedAnimation = appearAnimationStore.get(storeId);\n    if (!optimisedAnimation) {\n        return null;\n    }\n    const { animation, startTime } = optimisedAnimation;\n    const cancelAnimation = () => {\n        appearAnimationStore.delete(storeId);\n        if (frame) {\n            /**\n             * If we've been provided the frameloop as an argument, use it to defer\n             * cancellation until keyframes of the subsequent animation have been resolved.\n             * This \"papers over\" a gap where the JS animations haven't rendered with\n             * the latest time after a potential heavy blocking workload.\n             * Otherwise cancel immediately.\n             *\n             * This is an optional dependency to deal with the fact that this inline\n             * script and the library can be version sharded, and there have been\n             * times when this isn't provided as an argument.\n             */\n            frame.render(() => frame.render(() => {\n                try {\n                    animation.cancel();\n                }\n                catch (error) { }\n            }));\n        }\n        else {\n            try {\n                animation.cancel();\n            }\n            catch (error) { }\n        }\n    };\n    /**\n     * If the startTime is null, this animation is the Paint Ready detection animation\n     * and we can cancel it immediately without handoff.\n     *\n     * Or if we've already handed off the animation then we're now interrupting it.\n     * In which case we need to cancel it.\n     */\n    if (startTime === null || window.HandoffComplete) {\n        cancelAnimation();\n        return null;\n    }\n    else {\n        /**\n         * Otherwise we're handing off this animation to the main thread.\n         *\n         * Record the time of the first handoff. We call performance.now() once\n         * here and once in startOptimisedAnimation to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (handoffFrameTime === undefined) {\n            handoffFrameTime = performance.now();\n        }\n        /**\n         * We use main thread timings vs those returned by Animation.currentTime as it\n         * can be the case, particularly in Firefox, that currentTime doesn't return\n         * an updated value for several frames, even as the animation plays smoothly via\n         * the GPU.\n         */\n        return handoffFrameTime - startTime || 0;\n    }\n}\n\nexport { handoffOptimizedAppearAnimation };\n"],"mappings":"AAAA,SAASA,cAAT,QAA+B,uCAA/B;AACA,SAASC,oBAAT,QAAqC,aAArC;AACA,SAASC,aAAT,QAA8B,gBAA9B;AAEA,IAAIC,gBAAJ;;AACA,SAASC,+BAAT,CAAyCC,SAAzC,EAAoDC,SAApD;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,MAPA,EAOQC,KAPR,EAOe;EACX,IAAMC,kBAAkB,GAAGT,cAAc,CAACU,GAAf,CAAmBJ,SAAnB,IACrB,WADqB,GAErBA,SAFN;EAGA,IAAMK,OAAO,GAAGT,aAAa,CAACG,SAAD,EAAYI,kBAAZ,CAA7B;EACA,IAAMG,kBAAkB,GAAGX,oBAAoB,CAACY,GAArB,CAAyBF,OAAzB,CAA3B;;EACA,IAAI,CAACC,kBAAL,EAAyB;IACrB,OAAO,IAAP;EACH;;EACD,IAAQE,SAAR,GAAiCF,kBAAjC,CAAQE,SAAR;EAAA,IAAmBC,SAAnB,GAAiCH,kBAAjC,CAAmBG,SAAnB;;EACA,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,GAAM;IAC1Bf,oBAAoB,CAACgB,MAArB,CAA4BN,OAA5B;;IACA,IAAIH,KAAJ,EAAW;MACP;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYA,KAAK,CAACU,MAAN,CAAa;QAAA,OAAMV,KAAK,CAACU,MAAN,CAAa,YAAM;UAClC,IAAI;YACAJ,SAAS,CAACK,MAAV;UACH,CAFD,CAGA,OAAOC,KAAP,EAAc,CAAG;QACpB,CALkB,CAAN;MAAA,CAAb;IAMH,CAlBD,MAmBK;MACD,IAAI;QACAN,SAAS,CAACK,MAAV;MACH,CAFD,CAGA,OAAOC,KAAP,EAAc,CAAG;IACpB;EACJ,CA3BD;EA4BA;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACI,IAAIL,SAAS,KAAK,IAAd,IAAsBM,MAAM,CAACC,eAAjC,EAAkD;IAC9CN,eAAe;IACf,OAAO,IAAP;EACH,CAHD,MAIK;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAIb,gBAAgB,KAAKoB,SAAzB,EAAoC;MAChCpB,gBAAgB,GAAGqB,WAAW,CAACC,GAAZ,EAAnB;IACH;IACD;AACR;AACA;AACA;AACA;AACA;;;IACQ,OAAOtB,gBAAgB,GAAGY,SAAnB,IAAgC,CAAvC;EACH;AACJ;;AAED,SAASX,+BAAT"},"metadata":{},"sourceType":"module"}