{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"onComplete\", \"onUpdate\", \"motionValue\"],\n    _excluded2 = [\"motionValue\", \"onUpdate\", \"onComplete\"];\nimport { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nvar supportsWaapi = memo(function () {\n  return Object.hasOwnProperty.call(Element.prototype, \"animate\");\n});\n/**\n * A list of values that can be hardware-accelerated.\n */\n\nvar acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\" // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n// or until we implement support for linear() easing.\n// \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nvar sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nvar maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || options.name === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  }));\n  var state = {\n    done: false,\n    value: keyframes[0]\n  };\n  var pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  var t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nvar AcceleratedAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(AcceleratedAnimation, _BaseAnimation);\n\n  var _super = _createSuper(AcceleratedAnimation);\n\n  function AcceleratedAnimation(options) {\n    var _this;\n\n    _classCallCheck(this, AcceleratedAnimation);\n\n    _this = _super.call(this, options);\n    var _this$options = _this.options,\n        name = _this$options.name,\n        motionValue = _this$options.motionValue,\n        keyframes = _this$options.keyframes;\n    _this.resolver = new DOMKeyframesResolver(keyframes, function (resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    }, name, motionValue);\n\n    _this.resolver.scheduleResolve();\n\n    return _this;\n  }\n\n  _createClass(AcceleratedAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes, finalKeyframe) {\n      var _this2 = this;\n\n      var _a;\n\n      var _this$options2 = this.options,\n          _this$options2$durati = _this$options2.duration,\n          duration = _this$options2$durati === void 0 ? 300 : _this$options2$durati,\n          times = _this$options2.times,\n          ease = _this$options2.ease,\n          type = _this$options2.type,\n          motionValue = _this$options2.motionValue,\n          name = _this$options2.name;\n      /**\n       * If element has since been unmounted, return false to indicate\n       * the animation failed to initialised.\n       */\n\n      if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n        return false;\n      }\n      /**\n       * If this animation needs pre-generated keyframes then generate.\n       */\n\n\n      if (requiresPregeneratedKeyframes(this.options)) {\n        var _this$options3 = this.options,\n            onComplete = _this$options3.onComplete,\n            onUpdate = _this$options3.onUpdate,\n            _motionValue = _this$options3.motionValue,\n            options = _objectWithoutProperties(_this$options3, _excluded);\n\n        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n        keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n        // at least two keyframes to animate between as older browsers\n        // can't animate between a single keyframe.\n\n        if (keyframes.length === 1) {\n          keyframes[1] = keyframes[0];\n        }\n\n        duration = pregeneratedAnimation.duration;\n        times = pregeneratedAnimation.times;\n        ease = pregeneratedAnimation.ease;\n        type = \"keyframes\";\n      }\n\n      var animation = animateStyle(motionValue.owner.current, name, keyframes, _objectSpread(_objectSpread({}, this.options), {}, {\n        duration: duration,\n        times: times,\n        ease: ease\n      })); // Override the browser calculated startTime with one synchronised to other JS\n      // and WAAPI animations starting this event loop.\n\n      animation.startTime = time.now();\n\n      if (this.pendingTimeline) {\n        animation.timeline = this.pendingTimeline;\n        this.pendingTimeline = undefined;\n      } else {\n        /**\n         * Prefer the `onfinish` prop as it's more widely supported than\n         * the `finished` promise.\n         *\n         * Here, we synchronously set the provided MotionValue to the end\n         * keyframe. If we didn't, when the WAAPI animation is finished it would\n         * be removed from the element which would then revert to its old styles.\n         */\n        animation.onfinish = function () {\n          var onComplete = _this2.options.onComplete;\n          motionValue.set(getFinalKeyframe(keyframes, _this2.options, finalKeyframe));\n          onComplete && onComplete();\n\n          _this2.cancel();\n\n          _this2.resolveFinishedPromise();\n        };\n      }\n\n      return {\n        animation: animation,\n        duration: duration,\n        times: times,\n        type: type,\n        ease: ease,\n        keyframes: keyframes\n      };\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var duration = resolved.duration;\n      return millisecondsToSeconds(duration);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var animation = resolved.animation;\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n    set: function set(newTime) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.currentTime = secondsToMilliseconds(newTime);\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 1;\n      var animation = resolved.animation;\n      return animation.playbackRate;\n    },\n    set: function set(newSpeed) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.playbackRate = newSpeed;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return \"idle\";\n      var animation = resolved.animation;\n      return animation.playState;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      if (!this._resolved) {\n        this.pendingTimeline = timeline;\n      } else {\n        var resolved = this.resolved;\n        if (!resolved) return noop;\n        var animation = resolved.animation;\n        animation.timeline = timeline;\n        animation.onfinish = null;\n      }\n\n      return noop;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isStopped) return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n\n      if (animation.playState === \"finished\") {\n        this.updateFinishedPromise();\n      }\n\n      animation.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.pause();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation,\n          keyframes = resolved.keyframes,\n          duration = resolved.duration,\n          type = resolved.type,\n          ease = resolved.ease,\n          times = resolved.times;\n\n      if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n        return;\n      }\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n\n\n      if (this.time) {\n        var _this$options4 = this.options,\n            motionValue = _this$options4.motionValue,\n            onUpdate = _this$options4.onUpdate,\n            onComplete = _this$options4.onComplete,\n            options = _objectWithoutProperties(_this$options4, _excluded2);\n\n        var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n          keyframes: keyframes,\n          duration: duration,\n          type: type,\n          ease: ease,\n          times: times,\n          isGenerator: true\n        }));\n        var sampleTime = secondsToMilliseconds(this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n      }\n\n      this.cancel();\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.finish();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.cancel();\n    }\n  }], [{\n    key: \"supports\",\n    value: function supports(options) {\n      var motionValue = options.motionValue,\n          name = options.name,\n          repeatDelay = options.repeatDelay,\n          repeatType = options.repeatType,\n          damping = options.damping,\n          type = options.type;\n      return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n      /**\n       * If we're outputting values to onUpdate then we can't use WAAPI as there's\n       * no way to read the value from WAAPI every frame.\n       */\n      !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n    }\n  }]);\n\n  return AcceleratedAnimation;\n}(BaseAnimation);\n\nexport { AcceleratedAnimation };","map":{"version":3,"names":["time","DOMKeyframesResolver","memo","noop","millisecondsToSeconds","secondsToMilliseconds","BaseAnimation","MainThreadAnimation","animateStyle","isWaapiSupportedEasing","getFinalKeyframe","supportsWaapi","Object","hasOwnProperty","call","Element","prototype","acceleratedValues","Set","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","name","ease","pregenerateKeyframes","keyframes","sampleAnimation","repeat","delay","isGenerator","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","AcceleratedAnimation","motionValue","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","_a","owner","current","onComplete","onUpdate","pregeneratedAnimation","length","animation","startTime","now","pendingTimeline","timeline","onfinish","set","cancel","resolveFinishedPromise","resolved","currentTime","newTime","playbackRate","newSpeed","playState","_resolved","isStopped","updateFinishedPromise","play","pause","sampleTime","setWithVelocity","finish","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"sources":["C:/Users/pvplo/OneDrive/Рабочий стол/editpallav-main/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (options.type === \"spring\" ||\n        options.name === \"backgroundColor\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = animateStyle(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = time.now();\n        if (this.pendingTimeline) {\n            animation.timeline = this.pendingTimeline;\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            animation.timeline = timeline;\n            animation.onfinish = null;\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}