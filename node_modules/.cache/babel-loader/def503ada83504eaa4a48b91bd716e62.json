{"ast":null,"code":"import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia(_ref) {\n  var keyframes = _ref.keyframes,\n      _ref$velocity = _ref.velocity,\n      velocity = _ref$velocity === void 0 ? 0.0 : _ref$velocity,\n      _ref$power = _ref.power,\n      power = _ref$power === void 0 ? 0.8 : _ref$power,\n      _ref$timeConstant = _ref.timeConstant,\n      timeConstant = _ref$timeConstant === void 0 ? 325 : _ref$timeConstant,\n      _ref$bounceDamping = _ref.bounceDamping,\n      bounceDamping = _ref$bounceDamping === void 0 ? 10 : _ref$bounceDamping,\n      _ref$bounceStiffness = _ref.bounceStiffness,\n      bounceStiffness = _ref$bounceStiffness === void 0 ? 500 : _ref$bounceStiffness,\n      modifyTarget = _ref.modifyTarget,\n      min = _ref.min,\n      max = _ref.max,\n      _ref$restDelta = _ref.restDelta,\n      restDelta = _ref$restDelta === void 0 ? 0.5 : _ref$restDelta,\n      restSpeed = _ref.restSpeed;\n  var origin = keyframes[0];\n  var state = {\n    done: false,\n    value: origin\n  };\n\n  var isOutOfBounds = function isOutOfBounds(v) {\n    return min !== undefined && v < min || max !== undefined && v > max;\n  };\n\n  var nearestBoundary = function nearestBoundary(v) {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n\n  var amplitude = power * velocity;\n  var ideal = origin + amplitude;\n  var target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n\n  if (target !== ideal) amplitude = target - origin;\n\n  var calcDelta = function calcDelta(t) {\n    return -amplitude * Math.exp(-t / timeConstant);\n  };\n\n  var calcLatest = function calcLatest(t) {\n    return target + calcDelta(t);\n  };\n\n  var applyFriction = function applyFriction(t) {\n    var delta = calcDelta(t);\n    var latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n\n\n  var timeReachedBoundary;\n  var spring$1;\n\n  var checkCatchBoundary = function checkCatchBoundary(t) {\n    if (!isOutOfBounds(state.value)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      // TODO: This should be passing * 1000\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta: restDelta,\n      restSpeed: restSpeed\n    });\n  };\n\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: function next(t) {\n      /**\n       * We need to resolve the friction to figure out if we need a\n       * spring but we don't want to do this twice per frame. So here\n       * we flag if we updated for this frame and later if we did\n       * we can skip doing it again.\n       */\n      var hasUpdatedFrame = false;\n\n      if (!spring$1 && timeReachedBoundary === undefined) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      /**\n       * If we have a spring and the provided t is beyond the moment the friction\n       * animation crossed the min/max boundary, use the spring.\n       */\n\n\n      if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\n\nexport { inertia };","map":{"version":3,"names":["spring","calcGeneratorVelocity","inertia","keyframes","velocity","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","min","max","restDelta","restSpeed","origin","state","done","value","isOutOfBounds","v","undefined","nearestBoundary","Math","abs","amplitude","ideal","target","calcDelta","t","exp","calcLatest","applyFriction","delta","latest","timeReachedBoundary","spring$1","checkCatchBoundary","damping","stiffness","calculatedDuration","next","hasUpdatedFrame"],"sources":["C:/Users/pvplo/OneDrive/Рабочий стол/editpallav-main/node_modules/framer-motion/dist/es/animation/generators/inertia.mjs"],"sourcesContent":["import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}