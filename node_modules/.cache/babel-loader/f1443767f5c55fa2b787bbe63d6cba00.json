{"ast":null,"code":"import _slicedToArray from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/pvplo/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/editpallav-main/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { jsx } from 'react/jsx-runtime';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\nimport { microtask } from '../../../frameloop/microtask.mjs';\nimport { frame } from '../../../frameloop/frame.mjs';\n\nvar MeasureLayoutWithContext = /*#__PURE__*/function (_Component) {\n  _inherits(MeasureLayoutWithContext, _Component);\n\n  var _super = _createSuper(MeasureLayoutWithContext);\n\n  function MeasureLayoutWithContext() {\n    _classCallCheck(this, MeasureLayoutWithContext);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MeasureLayoutWithContext, [{\n    key: \"componentDidMount\",\n    value:\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    function componentDidMount() {\n      var _this = this;\n\n      var _this$props = this.props,\n          visualElement = _this$props.visualElement,\n          layoutGroup = _this$props.layoutGroup,\n          switchLayoutGroup = _this$props.switchLayoutGroup,\n          layoutId = _this$props.layoutId;\n      var projection = visualElement.projection;\n      addScaleCorrector(defaultScaleCorrectors);\n\n      if (projection) {\n        if (layoutGroup.group) layoutGroup.group.add(projection);\n\n        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n          switchLayoutGroup.register(projection);\n        }\n\n        projection.root.didUpdate();\n        projection.addEventListener(\"animationComplete\", function () {\n          _this.safeToRemove();\n        });\n        projection.setOptions(_objectSpread(_objectSpread({}, projection.options), {}, {\n          onExitComplete: function onExitComplete() {\n            return _this.safeToRemove();\n          }\n        }));\n      }\n\n      globalProjectionState.hasEverUpdated = true;\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          layoutDependency = _this$props2.layoutDependency,\n          visualElement = _this$props2.visualElement,\n          drag = _this$props2.drag,\n          isPresent = _this$props2.isPresent;\n      var projection = visualElement.projection;\n      if (!projection) return null;\n      /**\n       * TODO: We use this data in relegate to determine whether to\n       * promote a previous element. There's no guarantee its presence data\n       * will have updated by this point - if a bug like this arises it will\n       * have to be that we markForRelegation and then find a new lead some other way,\n       * perhaps in didUpdate\n       */\n\n      projection.isPresent = isPresent;\n\n      if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n        projection.willUpdate();\n      } else {\n        this.safeToRemove();\n      }\n\n      if (prevProps.isPresent !== isPresent) {\n        if (isPresent) {\n          projection.promote();\n        } else if (!projection.relegate()) {\n          /**\n           * If there's another stack member taking over from this one,\n           * it's in charge of the exit animation and therefore should\n           * be in charge of the safe to remove. Otherwise we call it here.\n           */\n          frame.postRender(function () {\n            var stack = projection.getStack();\n\n            if (!stack || !stack.members.length) {\n              _this2.safeToRemove();\n            }\n          });\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this3 = this;\n\n      var projection = this.props.visualElement.projection;\n\n      if (projection) {\n        projection.root.didUpdate();\n        microtask.postRender(function () {\n          if (!projection.currentAnimation && projection.isLead()) {\n            _this3.safeToRemove();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$props3 = this.props,\n          visualElement = _this$props3.visualElement,\n          layoutGroup = _this$props3.layoutGroup,\n          promoteContext = _this$props3.switchLayoutGroup;\n      var projection = visualElement.projection;\n\n      if (projection) {\n        projection.scheduleCheckAfterUnmount();\n        if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);\n        if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);\n      }\n    }\n  }, {\n    key: \"safeToRemove\",\n    value: function safeToRemove() {\n      var safeToRemove = this.props.safeToRemove;\n      safeToRemove && safeToRemove();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return MeasureLayoutWithContext;\n}(Component);\n\nfunction MeasureLayout(props) {\n  var _usePresence = usePresence(),\n      _usePresence2 = _slicedToArray(_usePresence, 2),\n      isPresent = _usePresence2[0],\n      safeToRemove = _usePresence2[1];\n\n  var layoutGroup = useContext(LayoutGroupContext);\n  return jsx(MeasureLayoutWithContext, _objectSpread(_objectSpread({}, props), {}, {\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  }));\n}\n\nvar defaultScaleCorrectors = {\n  borderRadius: _objectSpread(_objectSpread({}, correctBorderRadius), {}, {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":{"version":3,"names":["jsx","useContext","Component","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","correctBorderRadius","correctBoxShadow","addScaleCorrector","microtask","frame","MeasureLayoutWithContext","props","visualElement","layoutGroup","switchLayoutGroup","layoutId","projection","defaultScaleCorrectors","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","options","onExitComplete","hasEverUpdated","prevProps","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","stack","getStack","members","length","currentAnimation","isLead","promoteContext","scheduleCheckAfterUnmount","remove","deregister","MeasureLayout","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["C:/Users/pvplo/OneDrive/Рабочий стол/editpallav-main/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"sourcesContent":["import { jsx } from 'react/jsx-runtime';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\nimport { microtask } from '../../../frameloop/microtask.mjs';\nimport { frame } from '../../../frameloop/frame.mjs';\n\nclass MeasureLayoutWithContext extends Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n"],"mappings":";;;;;;AAAA,SAASA,GAAT,QAAoB,mBAApB;AACA,SAASC,UAAT,EAAqBC,SAArB,QAAsC,OAAtC;AACA,SAASC,WAAT,QAA4B,sDAA5B;AACA,SAASC,kBAAT,QAAmC,yCAAnC;AACA,SAASC,wBAAT,QAAyC,+CAAzC;AACA,SAASC,qBAAT,QAAsC,oCAAtC;AACA,SAASC,mBAAT,QAAoC,oDAApC;AACA,SAASC,gBAAT,QAAiC,iDAAjC;AACA,SAASC,iBAAT,QAAkC,iDAAlC;AACA,SAASC,SAAT,QAA0B,kCAA1B;AACA,SAASC,KAAT,QAAsB,8BAAtB;;IAEMC,wB;;;;;;;;;;;;;;IACF;AACJ;AACA;AACA;AACA;IACI,6BAAoB;MAAA;;MAChB,kBAAoE,KAAKC,KAAzE;MAAA,IAAQC,aAAR,eAAQA,aAAR;MAAA,IAAuBC,WAAvB,eAAuBA,WAAvB;MAAA,IAAoCC,iBAApC,eAAoCA,iBAApC;MAAA,IAAuDC,QAAvD,eAAuDA,QAAvD;MACA,IAAQC,UAAR,GAAuBJ,aAAvB,CAAQI,UAAR;MACAT,iBAAiB,CAACU,sBAAD,CAAjB;;MACA,IAAID,UAAJ,EAAgB;QACZ,IAAIH,WAAW,CAACK,KAAhB,EACIL,WAAW,CAACK,KAAZ,CAAkBC,GAAlB,CAAsBH,UAAtB;;QACJ,IAAIF,iBAAiB,IAAIA,iBAAiB,CAACM,QAAvC,IAAmDL,QAAvD,EAAiE;UAC7DD,iBAAiB,CAACM,QAAlB,CAA2BJ,UAA3B;QACH;;QACDA,UAAU,CAACK,IAAX,CAAgBC,SAAhB;QACAN,UAAU,CAACO,gBAAX,CAA4B,mBAA5B,EAAiD,YAAM;UACnD,KAAI,CAACC,YAAL;QACH,CAFD;QAGAR,UAAU,CAACS,UAAX,iCACOT,UAAU,CAACU,OADlB;UAEIC,cAAc,EAAE;YAAA,OAAM,KAAI,CAACH,YAAL,EAAN;UAAA;QAFpB;MAIH;;MACDpB,qBAAqB,CAACwB,cAAtB,GAAuC,IAAvC;IACH;;;WACD,iCAAwBC,SAAxB,EAAmC;MAAA;;MAC/B,mBAA6D,KAAKlB,KAAlE;MAAA,IAAQmB,gBAAR,gBAAQA,gBAAR;MAAA,IAA0BlB,aAA1B,gBAA0BA,aAA1B;MAAA,IAAyCmB,IAAzC,gBAAyCA,IAAzC;MAAA,IAA+CC,SAA/C,gBAA+CA,SAA/C;MACA,IAAMhB,UAAU,GAAGJ,aAAa,CAACI,UAAjC;MACA,IAAI,CAACA,UAAL,EACI,OAAO,IAAP;MACJ;AACR;AACA;AACA;AACA;AACA;AACA;;MACQA,UAAU,CAACgB,SAAX,GAAuBA,SAAvB;;MACA,IAAID,IAAI,IACJF,SAAS,CAACC,gBAAV,KAA+BA,gBAD/B,IAEAA,gBAAgB,KAAKG,SAFzB,EAEoC;QAChCjB,UAAU,CAACkB,UAAX;MACH,CAJD,MAKK;QACD,KAAKV,YAAL;MACH;;MACD,IAAIK,SAAS,CAACG,SAAV,KAAwBA,SAA5B,EAAuC;QACnC,IAAIA,SAAJ,EAAe;UACXhB,UAAU,CAACmB,OAAX;QACH,CAFD,MAGK,IAAI,CAACnB,UAAU,CAACoB,QAAX,EAAL,EAA4B;UAC7B;AAChB;AACA;AACA;AACA;UACgB3B,KAAK,CAAC4B,UAAN,CAAiB,YAAM;YACnB,IAAMC,KAAK,GAAGtB,UAAU,CAACuB,QAAX,EAAd;;YACA,IAAI,CAACD,KAAD,IAAU,CAACA,KAAK,CAACE,OAAN,CAAcC,MAA7B,EAAqC;cACjC,MAAI,CAACjB,YAAL;YACH;UACJ,CALD;QAMH;MACJ;;MACD,OAAO,IAAP;IACH;;;WACD,8BAAqB;MAAA;;MACjB,IAAQR,UAAR,GAAuB,KAAKL,KAAL,CAAWC,aAAlC,CAAQI,UAAR;;MACA,IAAIA,UAAJ,EAAgB;QACZA,UAAU,CAACK,IAAX,CAAgBC,SAAhB;QACAd,SAAS,CAAC6B,UAAV,CAAqB,YAAM;UACvB,IAAI,CAACrB,UAAU,CAAC0B,gBAAZ,IAAgC1B,UAAU,CAAC2B,MAAX,EAApC,EAAyD;YACrD,MAAI,CAACnB,YAAL;UACH;QACJ,CAJD;MAKH;IACJ;;;WACD,gCAAuB;MACnB,mBAA2E,KAAKb,KAAhF;MAAA,IAAQC,aAAR,gBAAQA,aAAR;MAAA,IAAuBC,WAAvB,gBAAuBA,WAAvB;MAAA,IAAuD+B,cAAvD,gBAAoC9B,iBAApC;MACA,IAAQE,UAAR,GAAuBJ,aAAvB,CAAQI,UAAR;;MACA,IAAIA,UAAJ,EAAgB;QACZA,UAAU,CAAC6B,yBAAX;QACA,IAAIhC,WAAW,IAAIA,WAAW,CAACK,KAA/B,EACIL,WAAW,CAACK,KAAZ,CAAkB4B,MAAlB,CAAyB9B,UAAzB;QACJ,IAAI4B,cAAc,IAAIA,cAAc,CAACG,UAArC,EACIH,cAAc,CAACG,UAAf,CAA0B/B,UAA1B;MACP;IACJ;;;WACD,wBAAe;MACX,IAAQQ,YAAR,GAAyB,KAAKb,KAA9B,CAAQa,YAAR;MACAA,YAAY,IAAIA,YAAY,EAA5B;IACH;;;WACD,kBAAS;MACL,OAAO,IAAP;IACH;;;;EAhGkCxB,S;;AAkGvC,SAASgD,aAAT,CAAuBrC,KAAvB,EAA8B;EAC1B,mBAAkCV,WAAW,EAA7C;EAAA;EAAA,IAAO+B,SAAP;EAAA,IAAkBR,YAAlB;;EACA,IAAMX,WAAW,GAAGd,UAAU,CAACG,kBAAD,CAA9B;EACA,OAAQJ,GAAG,CAACY,wBAAD,kCAAgCC,KAAhC;IAAuCE,WAAW,EAAEA,WAApD;IAAiEC,iBAAiB,EAAEf,UAAU,CAACI,wBAAD,CAA9F;IAA0H6B,SAAS,EAAEA,SAArI;IAAgJR,YAAY,EAAEA;EAA9J,GAAX;AACH;;AACD,IAAMP,sBAAsB,GAAG;EAC3BgC,YAAY,kCACL5C,mBADK;IAER6C,OAAO,EAAE,CACL,qBADK,EAEL,sBAFK,EAGL,wBAHK,EAIL,yBAJK;EAFD,EADe;EAU3BC,mBAAmB,EAAE9C,mBAVM;EAW3B+C,oBAAoB,EAAE/C,mBAXK;EAY3BgD,sBAAsB,EAAEhD,mBAZG;EAa3BiD,uBAAuB,EAAEjD,mBAbE;EAc3BkD,SAAS,EAAEjD;AAdgB,CAA/B;AAiBA,SAAS0C,aAAT"},"metadata":{},"sourceType":"module"}